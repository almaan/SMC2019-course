#!/usr/bin/env python3

import sys
import os.path as osp
from os import mkdir

sys.path.append(osp.abspath(__name__))

import numpy as np
import scipy.stats as st
from scipy.special import loggamma
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt

from utils import InverseGamma, BSPF, expNormalize


class PiTarget:
    def __init__(self,):
        pass

    def _insite(self,x):
        insite = np.linalg.norm(x,
                                ord = np.inf,
                                axis = 0)

        insite = (insite < 1) & (np.all(x > 0,axis = 0))
        return insite.astype(int)

    def logpdf(self,x):
        p1 = 2*np.log(np.abs(np.cos(x[0,:]*np.pi)))
        p2 = 6*np.log(np.abs(np.sin(x[1,:]*3*np.pi)))
        p3 = -30 * (x[0,:] ** 2 + x[1,:] ** 2)
        p =  p1 + p2 + p3
        p *= self._insite(x)
        p[p == 0] = -np.inf
        return p

    def pdf(self,x):
        return np.exp(self.logpdf(x))

    def temperlogpdf(self,x,k,K):
        return self.logpdf(x) * (k/K)

    def temperpdf(self,x,k,K):
        return np.exp(self.temperlogpdf(x,k,K))

    def sample0(self,N):
        return np.random.uniform(0,1,size = (2,N))


class InvMH:
    def __init__(self,
                 t_dist,
                 ):

        self.td = t_dist
        self.pd = lambda x : st.norm(x,0.02)

    def run(self,
            xk,
            niter,
            k,
            k,
           ):

        zs = xk[:].reshape(-1,1)
        zsmp = self.td.logpdf(zs,)

        for i in range(1,niter):
            _zs = self.pd(zs).rvs().reshape(-1,1)

            _zsmp = self.td.logpdf(_zs)

            alpha = np.exp(_zsmp - zsmp)
            alpha[np.isnan(alpha)] = 0
            alpha = np.min((1,alpha))

            u = np.random.random()

            if u <= alpha:
                zs = _zs[:]
                zsmp = _zsmp

        return zs

K = 200
n_particles = 200
xks = np.zeros((K,2,n_particles))
wss = np.zeros((K,n_particles))

gamma = PiTarget()

xks[0,:,:] = gamma.sample0(n_particles)
wss[0,:] = np.ones(n_particles) / n_particles
ess_thrs = 0.7*n_particles
logzratio = np.zeros(K)

resampler = InvMH(t_dist = gamma)

np.random.seed(1337)
rs_t = 0

for k in range(1,K):
    print(f"k : {k} / {K}")

    ess = 1.0 / (wss[k-1,:]**2).sum()
    print(f'ess is {ess}')

    zr = gamma.temperlogpdf(xks[k-1,:,:],k,K)
    zr -= gamma.temperlogpdf(xks[k-1,:,:],k-1,K)
    zr += np.log(wss[k-1,:])

    if ess < ess_thrs:
        print(f"Time since last resampling : {k - rs_t}")
        rs_t = k
        newx = np.zeros((2,n_particles))

        for p in range(n_particles):
            newx[:,p] = resampler.run(xks[k-1,:,p],
                                      niter = 500,
                                      k = k,
                                      K = K ).reshape(2,)

        xks[k,:,:] = newx
        wss[k,:] = 1/n_particles
    else:
        wss[k,:] = expNormalize(zr,inlog = True)
        xks[k,:,:] = xks[k-1,:,:]

    logzratio[k] = np.log(np.exp(zr).sum())

    zratio = np.exp(logzratio.sum())

    print(zratio)

print("FINAL")
print(zratio)
true_val = 0.00648817
diff = np.abs(zratio - true_val)
print(f"Difference estimate True : {diff}")




